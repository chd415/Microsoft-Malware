import pandas as pd
import numpy as np
import lightgbm as lgb
from scipy.sparse import vstack, csr_matrix, save_npz, load_npz
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import roc_auc_score
from tqdm import tqdm_notebook
import gc
import datetime
gc.enable()

class Unbuffered(object):
   def __init__(self, stream):
       self.stream = stream
   def write(self, data):
       self.stream.write(data)
       self.stream.flush()
   def writelines(self, datas):
       self.stream.writelines(datas)
       self.stream.flush()
   def __getattr__(self, attr):
       return getattr(self.stream, attr)

import sys
sys.stdout = Unbuffered(sys.stdout)

dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        'HasDetections':                                        'int8'
        }

print('Download Train and Test Data: ', datetime.datetime.now())
##nrows=1000000
train = pd.read_csv('../MicrosoftMalware/train.csv', dtype=dtypes, low_memory=True)
train['MachineIdentifier'] = train.index.astype('uint32')
test  = pd.read_csv('../MicrosoftMalware/test.csv',  dtype=dtypes, low_memory=True)
test['MachineIdentifier']  = test.index.astype('uint32')

gc.collect()   

print('fe1:',  datetime.datetime.now())
fe1 = True
if fe1:
    train['Census_GenuineStateName'].fillna('UNKNOWN', inplace=True)
    test['Census_GenuineStateName'].fillna('UNKNOWN', inplace=True)
    col = 'Census_ChassisTypeName'
    train[col] = train[col].fillna('Unknown')
    test[col] = test[col].fillna('Unknown')
    #this has unkown and unspecieifed, maybe we can combine the two
    col = 'Census_PrimaryDiskTypeName'
    train[col] = train[col].fillna('UNKNOWN')
    test[col] = test[col].fillna('UNKNOWN')

    def rename_edition(x):
        x = x.lower()
        if 'core' in x:
            return 'Core'
        elif 'pro' in x:
            return 'pro'
        elif 'enterprise' in x:
            return 'Enterprise'
        elif 'server' in x:
            return 'Server'
        elif 'home' in x:
            return 'Home'
        elif 'education' in x:
            return 'Education'
        elif 'cloud' in x:
            return 'Cloud'
        else:
            return x
    train['Census_OSEdition'] = train['Census_OSEdition'].apply(rename_edition)
    test['Census_OSEdition'] = test['Census_OSEdition'].apply(rename_edition)
    train['Census_OSSkuName'] = train['Census_OSSkuName'].apply(rename_edition)
    test['Census_OSSkuName'] = test['Census_OSSkuName'].apply(rename_edition)

def fe(df):
    
    df['OsBuildLab'] = df['OsBuildLab'].cat.add_categories(['0.0.0.0.0-0'])
    df['OsBuildLab'] = df['OsBuildLab'].fillna('0.0.0.0.0-0')
    
    df['EngineVersion_2'] = df['EngineVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    df['EngineVersion_3'] = df['EngineVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    df['AppVersion_1'] = df['AppVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    df['AppVersion_2'] = df['AppVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    df['AppVersion_3'] = df['AppVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    df['AvSigVersion_0'] = df['AvSigVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    df['AvSigVersion_1'] = df['AvSigVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    df['AvSigVersion_2'] = df['AvSigVersion'].apply(lambda x: x.split('.')[2]).astype('category')

    df['OsBuildLab_0'] = df['OsBuildLab'].apply(lambda x: x.split('.')[0]).astype('category')
    df['OsBuildLab_1'] = df['OsBuildLab'].apply(lambda x: x.split('.')[1]).astype('category')
    df['OsBuildLab_2'] = df['OsBuildLab'].apply(lambda x: x.split('.')[2]).astype('category')
    df['OsBuildLab_3'] = df['OsBuildLab'].apply(lambda x: x.split('.')[3]).astype('category')
    # df['OsBuildLab_40'] = df['OsBuildLab'].apply(lambda x: x.split('.')[4].split('-')[0]).astype('category')
    # df['OsBuildLab_41'] = df['OsBuildLab'].apply(lambda x: x.split('.')[4].split('-')[1]).astype('category')

    df['Census_OSVersion_0'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    df['Census_OSVersion_1'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    df['Census_OSVersion_2'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    df['Census_OSVersion_3'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    # https://www.kaggle.com/adityaecdrid/simple-feature-engineering-xd
    df['primary_drive_c_ratio'] = df['Census_SystemVolumeTotalCapacity']/ df['Census_PrimaryDiskTotalCapacity']
    df['non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']

    df['aspect_ratio'] = df['Census_InternalPrimaryDisplayResolutionHorizontal']/ df['Census_InternalPrimaryDisplayResolutionVertical']

    df['monitor_dims'] = df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(str) + '*' + df['Census_InternalPrimaryDisplayResolutionVertical'].astype('str')
    df['monitor_dims'] = df['monitor_dims'].astype('category')

    df['dpi'] = ((df['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + df['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5)/(df['Census_InternalPrimaryDiagonalDisplaySizeInInches'])

    df['dpi_square'] = df['dpi'] ** 2

    df['MegaPixels'] = (df['Census_InternalPrimaryDisplayResolutionHorizontal'] * df['Census_InternalPrimaryDisplayResolutionVertical'])/1e6

    df['Screen_Area'] = (df['aspect_ratio']* (df['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2))/(df['aspect_ratio']**2 + 1)

    df['ram_per_processor'] = df['Census_TotalPhysicalRAM']/ df['Census_ProcessorCoreCount']

    df['new_num_0'] = df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] / df['Census_ProcessorCoreCount']

    df['new_num_1'] = df['Census_ProcessorCoreCount'] * df['Census_InternalPrimaryDiagonalDisplaySizeInInches']
    
    df['Census_IsFlightingInternal'] = df['Census_IsFlightingInternal'].fillna(1)
    df['Census_ThresholdOptIn'] = df['Census_ThresholdOptIn'].fillna(1)
    df['Census_IsWIMBootEnabled'] = df['Census_IsWIMBootEnabled'].fillna(1)
    df['Wdft_IsGamer'] = df['Wdft_IsGamer'].fillna(0)
    
    return df

print('ADD to 120:',  datetime.datetime.now())
train = fe(train)
test = fe(test)


add_cat_feats = [
 'Census_OSBuildRevision',
 'OsBuildLab',
 'SmartScreen',
'AVProductsInstalled']
for col1 in add_cat_feats:
    for col2 in add_cat_feats:
        if col1 != col2:
            train[col1 + '__' + col2] = train[col1].astype(str) + train[col2].astype(str)
            train[col1 + '__' + col2] = train[col1 + '__' + col2].astype('category')
            
            test[col1 + '__' + col2] = test[col1].astype(str) + test[col2].astype(str)
            test[col1 + '__' + col2] = test[col1 + '__' + col2].astype('category')


print('fe2:',  datetime.datetime.now())

fe2 = True
if fe2:
    train_shape = train.shape
    test_shape = test.shape
    all_data = pd.concat((train,test),axis=0)

    all_data['AvSigVersion'].fillna('UNKNOWN', inplace=True)
    all_data['Wdft_IsGamer'].fillna('UNKNOWN', inplace=True)
    all_data['Census_OSInstallLanguageIdentifier'].fillna('UNKNOWN', inplace=True)

    all_data['Census_ProcessorCoreCount'].fillna('UNKNOWN', inplace=True)
    all_data['Wdft_RegionIdentifier'].fillna('UNKNOWN', inplace=True)
    all_data['Census_OSBuildNumber'].fillna('UNKNOWN', inplace=True)

    all_data['Census_ProcessorCoreCount'].fillna('UNKNOWN', inplace=True)
    all_data['Census_OEMNameIdentifier'].fillna('UNKNOWN', inplace=True)
    all_data['CityIdentifier'].fillna('UNKNOWN', inplace=True)

    all_data['GeoNameIdentifier'].fillna('UNKNOWN', inplace=True)
    all_data['Census_OEMNameIdentifier'].fillna('UNKNOWN', inplace=True)
    all_data['Census_OSBuildRevision'].fillna('UNKNOWN', inplace=True)


    for col in all_data.columns:
        all_data[col] = all_data[col].astype('category')
    f1list = ['AvSigVersion',
                                 'Wdft_IsGamer',
                                 'Census_OSInstallLanguageIdentifier']
    f2list = ['Census_ProcessorCoreCount',
                                 'Wdft_RegionIdentifier',
                                 'Census_OSBuildNumber']
    f3list = ['Census_ProcessorCoreCount',
                                 'Census_OEMNameIdentifier',
                                 'CityIdentifier']
    f4list = ['GeoNameIdentifier',
                                 'Census_OEMNameIdentifier',
                                 'Census_OSBuildRevision']


    flist = [f1list,f2list,f3list,f4list]
    for i in tqdm_notebook(range(4)):
        temp = all_data.groupby(flist[i]).size().reset_index(name='counts'+str(i))
        all_data = pd.merge(all_data, temp,  how='left', left_on=flist[i], right_on = flist[i])
        col = 'counts'+str(i)
        all_data[col] = all_data[col].astype('int32')
    train = all_data[:train_shape[0]]
    test = all_data[train_shape[0]:]
    del all_data, temp
    gc.collect()

cols = train.columns.tolist()
first = cols.index('MachineIdentifier')
last = cols.index('HasDetections')
cols[0], cols[first]  = cols[first], cols[0]
cols[-1], cols[last]  = cols[last], cols[-1]
train = train[cols]
test = test[cols[:-1]]
test = test.reset_index(drop=True)

print('Transform all features to category:',  datetime.datetime.now())
for usecol in train.columns.tolist()[1:-1]:

    train[usecol] = train[usecol].astype('str')
    test[usecol] = test[usecol].astype('str')
    
    #Fit LabelEncoder
    le = LabelEncoder().fit(
            np.unique(train[usecol].unique().tolist()+
                      test[usecol].unique().tolist()))

    #At the end 0 will be used for dropped values
    train[usecol] = le.transform(train[usecol])+1
    test[usecol]  = le.transform(test[usecol])+1

    agg_tr = (train
              .groupby([usecol])
              .aggregate({'MachineIdentifier':'count'})
              .reset_index()
              .rename({'MachineIdentifier':'Train'}, axis=1))
    agg_te = (test
              .groupby([usecol])
              .aggregate({'MachineIdentifier':'count'})
              .reset_index()
              .rename({'MachineIdentifier':'Test'}, axis=1))

    agg = pd.merge(agg_tr, agg_te, on=usecol, how='outer').replace(np.nan, 0)
    #Select values with more than 1000 observations
    agg = agg[(agg['Train'] > 1000)].reset_index(drop=True)
    agg['Total'] = agg['Train'] + agg['Test']
    #Drop unbalanced values
    agg = agg[(agg['Train'] / agg['Total'] > 0.2) & (agg['Train'] / agg['Total'] < 0.8)]
    agg[usecol+'Copy'] = agg[usecol]

    train[usecol] = (pd.merge(train[[usecol]], 
                              agg[[usecol, usecol+'Copy']], 
                              on=usecol, how='left')[usecol+'Copy']
                     .replace(np.nan, 0).astype('int').astype('category'))

    test[usecol]  = (pd.merge(test[[usecol]], 
                              agg[[usecol, usecol+'Copy']], 
                              on=usecol, how='left')[usecol+'Copy']
                     .replace(np.nan, 0).astype('int').astype('category'))

    del le, agg_tr, agg_te, agg, usecol
    gc.collect()

y_train = train['HasDetections']
del train['HasDetections'], train['MachineIdentifier'], test['MachineIdentifier']
gc.collect()
          
all_data = pd.concat((train,test),axis=0)
ohe = OneHotEncoder(categories='auto', sparse=True, dtype='uint8').fit(all_data)
del all_data

skf = StratifiedKFold(n_splits=3, shuffle=True, random_state=42)
skf.get_n_splits(train.index, y_train)

test_result = np.zeros(len(test))
test = ohe.transform(test)
test = csr_matrix(test, dtype='float32')


for train_index, test_index in skf.split(train.index, y_train):
    X_fit, X_val = train[train.index.isin(train_index)],   train[train.index.isin(test_index)]
    y_fit, y_val = y_train[y_train.index.isin(train_index)], y_train[y_train.index.isin(test_index)]

    X_fit, X_val = ohe.transform(X_fit), ohe.transform(X_val)
    X_fit, X_val = csr_matrix(X_fit, dtype='float32'), csr_matrix(X_val, dtype='float32')
    print('Train :',  datetime.datetime.now())    
#    model = lgb.LGBMClassifier(max_depth=-1,
#                               n_estimators=30000,
#                               learning_rate=0.075,
#                               colsample_bytree=0.15,
#                               objective='binary', 
#                               n_jobs= 16)      


    model = lgb.LGBMClassifier(max_depth=-1,
                                    n_estimators=30000,
                                    learning_rate=0.01,
                                    num_leaves=2**11-1,
                                    colsample_bytree=0.3,
                                    objective='binary', 
                                    n_jobs=16)
    
    
    model.fit(X_fit, y_fit, eval_metric='auc', eval_set=[(X_val, y_val)], 
              verbose=100, early_stopping_rounds=100)
    
    test_result += model.predict_proba(test)[:,1] 
    del X_fit, X_val, y_fit, y_val
    gc.collect()


to_submit = pd.read_csv('../MicrosoftMalware/sample_submission.csv')
to_submit['HasDetections'] = test_result / 3
to_submit.to_csv('scriptest.csv', index=False)
print(to_submit.head())

f.close()
